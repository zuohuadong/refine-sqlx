# Refine SQLX

[English](#english) | [‰∏≠Êñá](#‰∏≠Êñá)

## English

A powerful, type-safe data provider for [Refine](https://refine.dev) with multi-database support using modern [Drizzle ORM](https://orm.drizzle.team).

## Features

- üöÄ **Multi-database support**: PostgreSQL, MySQL, SQLite
- üîí **Type-safe**: Full TypeScript 5.0+ support with schema inference
- ‚ö° **Runtime detection**: Automatic driver selection (Bun, Node.js, Cloudflare)
- üîó **Advanced relationships**: Polymorphic associations and complex queries
- üéØ **Chain queries**: Fluent query builder interface
- üîÑ **Transactions**: Full transaction support across all databases
- üì¶ **Tree-shakable**: Import only what you need
- üé® **Modern Drizzle**: Latest Drizzle ORM features and optimizations
- üè∑Ô∏è **TypeScript 5.0**: Support for new standard decorators and latest features

## Installation

```bash
npm install @@refine-sqlx/sqlx/sqlx drizzle-orm
# or
bun add @@refine-sqlx/sqlx/sqlx drizzle-orm
```

### Database Drivers

Install the appropriate database driver for your setup:

```bash
# PostgreSQL
npm install postgres  # Node.js
# Bun uses built-in bun:sql for PostgreSQL

# MySQL
npm install mysql2    # All environments (Bun doesn't support MySQL in bun:sql yet)

# SQLite
npm install better-sqlite3  # Node.js
# Bun uses built-in bun:sqlite
```

## Quick Start

### 1. Define Your Schema (Modern Drizzle ORM)

```typescript
import {
  pgTable,
  serial,
  varchar,
  timestamp,
  text,
  integer,
  uuid,
  jsonb,
  index,
  uniqueIndex,
  foreignKey,
} from 'drizzle-orm/pg-core';

export const users = pgTable(
  'users',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    name: varchar('name', { length: 255 }).notNull(),
    email: varchar('email', { length: 255 }).notNull(),
    metadata: jsonb('metadata').$type<{
      preferences: Record<string, any>;
      settings: Record<string, any>;
    }>(),
    createdAt: timestamp('created_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  table => ({
    emailIdx: uniqueIndex('users_email_idx').on(table.email),
    nameIdx: index('users_name_idx').on(table.name),
  })
);

export const posts = pgTable(
  'posts',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    title: varchar('title', { length: 500 }).notNull(),
    content: text('content'),
    authorId: uuid('author_id').notNull(),
    tags: jsonb('tags').$type<string[]>().default([]),
    status: varchar('status', {
      length: 20,
      enum: ['draft', 'published'],
    }).default('draft'),
    createdAt: timestamp('created_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  table => ({
    authorFk: foreignKey({
      columns: [table.authorId],
      foreignColumns: [users.id],
    }).onDelete('cascade'),
    statusIdx: index('posts_status_idx').on(table.status),
  })
);

export const schema = { users, posts };
```

### 2. Create Data Provider

#### PostgreSQL

```typescript
import { createPostgreSQLProvider } from '@refine-sqlx/sqlx';
import { schema } from './schema';

// Connection string
const dataProvider = await createPostgreSQLProvider(
  'postgresql://user:password@localhost:5432/mydb',
  schema
);

// Connection object
const dataProvider = await createPostgreSQLProvider(
  {
    host: 'localhost',
    port: 5432,
    user: 'postgres',
    password: 'password',
    database: 'mydb',
  },
  schema
);
```

#### MySQL

```typescript
import { createMySQLProvider } from '@refine-sqlx/sqlx';
import { schema } from './schema';

const dataProvider = await createMySQLProvider(
  'mysql://user:password@localhost:3306/mydb',
  schema
);
```

#### SQLite

```typescript
import { createSQLiteProvider } from '@refine-sqlx/sqlx';
import { schema } from './schema';

// File database
const dataProvider = await createSQLiteProvider('./database.db', schema);

// In-memory database
const dataProvider = await createSQLiteProvider(':memory:', schema);

// Cloudflare D1
const dataProvider = await createSQLiteProvider(env.DB, schema);
```

### 3. Use with Refine

```typescript
import { Refine } from '@refinedev/core';
import { dataProvider } from './data-provider';

function App() {
  return (
    <Refine
      dataProvider={dataProvider}
      resources={[
        {
          name: 'users',
          list: '/users',
          create: '/users/create',
          edit: '/users/edit/:id',
          show: '/users/show/:id',
        },
      ]}>
      {/* Your app components */}
    </Refine>
  );
}
```

## Advanced Usage

### Chain Queries

```typescript
// Get users with pagination and filtering
const users = await dataProvider
  .from('users')
  .where('email', 'like', '%@example.com')
  .orderBy('createdAt', 'desc')
  .limit(10)
  .offset(20)
  .get();

// Count with filters
const count = await dataProvider
  .from('users')
  .where('active', '=', true)
  .count();

// Complex queries
const result = await dataProvider
  .from('posts')
  .where('published', '=', true)
  .where('createdAt', '>', new Date('2024-01-01'))
  .orderBy('createdAt', 'desc')
  .with(['user']) // Include relationships
  .paginate(1, 20);
```

### Polymorphic Relationships

```typescript
import { createMorphConfig } from '@refine-sqlx/sqlx';

// Define polymorphic relationship
const morphConfig = createMorphConfig({
  morphType: 'commentable_type',
  morphId: 'commentable_id',
  types: { post: posts, user: users },
});

// Query polymorphic data
const comments = await dataProvider
  .morph('comments', morphConfig)
  .where('approved', '=', true)
  .withMorphRelations()
  .get();
```

### TypeScript 5.0 Decorators (Optional Enhancement)

RefineSQLX supports TypeScript 5.0's new standard decorators for enhanced metadata and validation:

```typescript
// Enable in tsconfig.json:
// "experimentalDecorators": false,
// "emitDecoratorMetadata": false

@Entity('users')
class User {
  @PrimaryKey()
  @Column({ type: 'uuid' })
  id!: string;

  @Column({ type: 'varchar', length: 255 })
  @Index('idx_user_name')
  name!: string;

  @Column({ type: 'varchar', length: 255 })
  @Index('idx_user_email')
  email!: string;

  @Column({ type: 'jsonb' })
  metadata?: Record<string, any>;

  @Validate()
  save() {
    console.log('Saving user:', this);
  }
}

// Use with RefineSQLX
const user = new User();
user.name = 'John Doe';
user.email = 'john@example.com';
user.save(); // Decorator will log validation

// Still use Drizzle schema for database operations
const result = await dataProvider.create({
  resource: 'users',
  variables: { name: user.name, email: user.email },
});
```

### Transactions

```typescript
import { TransactionManager } from '@refine-sqlx/sqlx';

const transactionManager = new TransactionManager(dataProvider);

await transactionManager.execute(async tx => {
  // Create user
  const user = await tx.create({
    resource: 'users',
    variables: { name: 'John', email: 'john@example.com' },
  });

  // Create posts for the user
  await tx.createMany({
    resource: 'posts',
    variables: [
      { title: 'Post 1', authorId: user.data.id },
      { title: 'Post 2', authorId: user.data.id },
    ],
  });
});
```

### Raw SQL Queries

```typescript
// Execute raw SQL
const result = await dataProvider.raw(
  'SELECT * FROM users WHERE created_at > ?',
  [new Date('2024-01-01')]
);

// Use native Drizzle queries
const client = dataProvider.getClient();
const users = await client
  .select()
  .from(schema.users)
  .where(gt(schema.users.createdAt, new Date('2024-01-01')));
```

## Configuration Options

### Connection Pooling

```typescript
const dataProvider = await createPostgreSQLProvider(connectionString, schema, {
  pool: {
    min: 2,
    max: 10,
    acquireTimeoutMillis: 30000,
    createTimeoutMillis: 30000,
    idleTimeoutMillis: 600000,
  },
});
```

### Logging and Debugging

```typescript
const dataProvider = await createPostgreSQLProvider(connectionString, schema, {
  debug: true,
  logger: (query, params) => {
    console.log('Query:', query);
    console.log('Params:', params);
  },
});
```

## Runtime Support

| Runtime            | PostgreSQL  | MySQL     | SQLite            |
| ------------------ | ----------- | --------- | ----------------- |
| Bun                | ‚úÖ bun:sql  | ‚úÖ mysql2 | ‚úÖ bun:sqlite     |
| Node.js            | ‚úÖ postgres | ‚úÖ mysql2 | ‚úÖ better-sqlite3 |
| Cloudflare Workers | ‚ùå          | ‚ùå        | ‚úÖ D1             |

## Error Handling

```typescript
import {
  ConnectionError,
  QueryError,
  ValidationError,
  TransactionError,
} from '@refine-sqlx/sqlx';

try {
  const result = await dataProvider.getList({ resource: 'users' });
} catch (error) {
  if (error instanceof ConnectionError) {
    console.error('Database connection failed:', error.message);
  } else if (error instanceof QueryError) {
    console.error('Query execution failed:', error.message);
  } else if (error instanceof ValidationError) {
    console.error('Data validation failed:', error.message);
  }
}
```

## Migration from Other Providers

### From Simple REST

```typescript
// Before
const dataProvider = simpleRestProvider('http://localhost:3000/api');

// After
const dataProvider = await createPostgreSQLProvider(connectionString, schema);
```

### From Supabase

```typescript
// Before
const dataProvider = supabaseDataProvider(supabaseClient);

// After - using PostgreSQL connection
const dataProvider = await createPostgreSQLProvider(
  process.env.DATABASE_URL,
  schema
);
```

## API Reference

### Core Functions

- `createPostgreSQLProvider(connection, schema, options?)` - Create PostgreSQL data provider
- `createMySQLProvider(connection, schema, options?)` - Create MySQL data provider
- `createSQLiteProvider(connection, schema, options?)` - Create SQLite data provider
- `createProvider(config)` - Universal provider factory

### Chain Query Methods

- `.where(field, operator, value)` - Add WHERE condition
- `.orderBy(field, direction)` - Add ORDER BY clause
- `.limit(count)` - Set LIMIT
- `.offset(count)` - Set OFFSET
- `.with(relations)` - Include relationships
- `.get()` - Execute and get results
- `.first()` - Get first result
- `.count()` - Get count
- `.paginate(page, perPage)` - Paginated results

### Utility Functions

- `testConnection(connectionString)` - Test database connection
- `validateSchema(schema)` - Validate Drizzle schema
- `getRuntimeInfo()` - Get runtime and driver information

## Contributing

We welcome contributions! Please see our [Contributing Guide](../../CONTRIBUTING.md) for details.

## License

## MIT ¬© [RefineSQLX Team](https://github.com/zuohuadong/@refine-sqlx/sql)

## ‰∏≠Êñá

‰∏Ä‰∏™Âº∫Â§ßÁöÑ„ÄÅÁ±ªÂûãÂÆâÂÖ®ÁöÑ [Refine](https://refine.dev) Êï∞ÊçÆÊèê‰æõÂô®Ôºå‰ΩøÁî® [Drizzle ORM](https://orm.drizzle.team) ÊîØÊåÅÂ§öÊï∞ÊçÆÂ∫ì„ÄÇ

## ÂäüËÉΩÁâπÊÄß

- üöÄ **Â§öÊï∞ÊçÆÂ∫ìÊîØÊåÅ**: PostgreSQL, MySQL, SQLite
- üîí **Á±ªÂûãÂÆâÂÖ®**: ÂÆåÊï¥ÁöÑ TypeScript ÊîØÊåÅÂíåÊ®°ÂºèÊé®Êñ≠
- ‚ö° **ËøêË°åÊó∂Ê£ÄÊµã**: Ëá™Âä®È©±Âä®ÈÄâÊã© (Bun, Node.js, Cloudflare)
- üîó **È´òÁ∫ßÂÖ≥Á≥ª**: Â§öÊÄÅÂÖ≥ËÅîÂíåÂ§çÊùÇÊü•ËØ¢
- üéØ **ÈìæÂºèÊü•ËØ¢**: ÊµÅÁïÖÁöÑÊü•ËØ¢ÊûÑÂª∫Âô®Êé•Âè£
- üîÑ **‰∫ãÂä°**: ÊâÄÊúâÊï∞ÊçÆÂ∫ìÁöÑÂÆåÊï¥‰∫ãÂä°ÊîØÊåÅ
- üì¶ **Tree-shakable**: Âè™ÂØºÂÖ•ÊÇ®ÈúÄË¶ÅÁöÑÂÜÖÂÆπ

## ÂÆâË£Ö

```bash
npm install @@refine-sqlx/sqlx/sqlx drizzle-orm
# Êàñ
bun add @@refine-sqlx/sqlx/sqlx drizzle-orm
```

### Êï∞ÊçÆÂ∫ìÈ©±Âä®

‰∏∫ÊÇ®ÁöÑËÆæÁΩÆÂÆâË£ÖÈÄÇÂΩìÁöÑÊï∞ÊçÆÂ∫ìÈ©±Âä®Ôºö

```bash
# PostgreSQL
npm install postgres  # Node.js
# Bun ‰ΩøÁî®ÂÜÖÁΩÆÁöÑ bun:sql ÊîØÊåÅ PostgreSQL

# MySQL
npm install mysql2    # ÊâÄÊúâÁéØÂ¢É (Bun ÁöÑ bun:sql Ëøò‰∏çÊîØÊåÅ MySQL)

# SQLite
npm install better-sqlite3  # Node.js
# Bun ‰ΩøÁî®ÂÜÖÁΩÆÁöÑ bun:sqlite
```

## Âø´ÈÄüÂºÄÂßã

### 1. ÂÆö‰πâÊÇ®ÁöÑÊ®°Âºè

```typescript
import { pgTable, serial, varchar, timestamp } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }).notNull(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  createdAt: timestamp('created_at').defaultNow(),
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: varchar('title', { length: 255 }).notNull(),
  content: text('content'),
  userId: integer('user_id').references(() => users.id),
  createdAt: timestamp('created_at').defaultNow(),
});

export const schema = { users, posts };
```

### 2. ÂàõÂª∫Êï∞ÊçÆÊèê‰æõÂô®

#### PostgreSQL

```typescript
import { createPostgreSQLProvider } from '@refine-sqlx/sqlx';
import { schema } from './schema';

// ËøûÊé•Â≠óÁ¨¶‰∏≤
const dataProvider = await createPostgreSQLProvider(
  'postgresql://user:password@localhost:5432/mydb',
  schema
);

// ËøûÊé•ÂØπË±°
const dataProvider = await createPostgreSQLProvider(
  {
    host: 'localhost',
    port: 5432,
    user: 'postgres',
    password: 'password',
    database: 'mydb',
  },
  schema
);
```

#### MySQL

```typescript
import { createMySQLProvider } from '@refine-sqlx/sqlx';
import { schema } from './schema';

const dataProvider = await createMySQLProvider(
  'mysql://user:password@localhost:3306/mydb',
  schema
);
```

#### SQLite

```typescript
import { createSQLiteProvider } from '@refine-sqlx/sqlx';
import { schema } from './schema';

// Êñá‰ª∂Êï∞ÊçÆÂ∫ì
const dataProvider = await createSQLiteProvider('./database.db', schema);

// ÂÜÖÂ≠òÊï∞ÊçÆÂ∫ì
const dataProvider = await createSQLiteProvider(':memory:', schema);

// Cloudflare D1
const dataProvider = await createSQLiteProvider(env.DB, schema);
```

### 3. ‰∏é Refine ‰∏ÄËµ∑‰ΩøÁî®

```typescript
import { Refine } from '@refinedev/core';
import { dataProvider } from './data-provider';

function App() {
  return (
    <Refine
      dataProvider={dataProvider}
      resources={[
        {
          name: 'users',
          list: '/users',
          create: '/users/create',
          edit: '/users/edit/:id',
          show: '/users/show/:id',
        },
      ]}>
      {/* ÊÇ®ÁöÑÂ∫îÁî®ÁªÑ‰ª∂ */}
    </Refine>
  );
}
```

## È´òÁ∫ßÁî®Ê≥ï

### ÈìæÂºèÊü•ËØ¢

```typescript
// Ëé∑ÂèñÂ∏¶ÂàÜÈ°µÂíåËøáÊª§ÁöÑÁî®Êà∑
const users = await dataProvider
  .from('users')
  .where('email', 'like', '%@example.com')
  .orderBy('createdAt', 'desc')
  .limit(10)
  .offset(20)
  .get();

// Â∏¶ËøáÊª§Âô®ÁöÑËÆ°Êï∞
const count = await dataProvider
  .from('users')
  .where('active', '=', true)
  .count();

// Â§çÊùÇÊü•ËØ¢
const result = await dataProvider
  .from('posts')
  .where('published', '=', true)
  .where('createdAt', '>', new Date('2024-01-01'))
  .orderBy('createdAt', 'desc')
  .with(['user']) // ÂåÖÂê´ÂÖ≥Á≥ª
  .paginate(1, 20);
```

### Â§öÊÄÅÂÖ≥Á≥ª

```typescript
import { createMorphConfig } from '@refine-sqlx/sqlx';

// ÂÆö‰πâÂ§öÊÄÅÂÖ≥Á≥ª
const morphConfig = createMorphConfig({
  morphType: 'commentable_type',
  morphId: 'commentable_id',
  types: { post: posts, user: users },
});

// Êü•ËØ¢Â§öÊÄÅÊï∞ÊçÆ
const comments = await dataProvider
  .morph('comments', morphConfig)
  .where('approved', '=', true)
  .withMorphRelations()
  .get();
```

### ‰∫ãÂä°

```typescript
import { TransactionManager } from '@refine-sqlx/sqlx';

const transactionManager = new TransactionManager(dataProvider);

await transactionManager.execute(async tx => {
  // ÂàõÂª∫Áî®Êà∑
  const user = await tx.create({
    resource: 'users',
    variables: { name: 'John', email: 'john@example.com' },
  });

  // ‰∏∫Áî®Êà∑ÂàõÂª∫ÊñáÁ´†
  await tx.createMany({
    resource: 'posts',
    variables: [
      { title: 'Post 1', userId: user.data.id },
      { title: 'Post 2', userId: user.data.id },
    ],
  });
});
```

### ÂéüÁîü SQL Êü•ËØ¢

```typescript
// ÊâßË°åÂéüÁîü SQL
const result = await dataProvider.raw(
  'SELECT * FROM users WHERE created_at > ?',
  [new Date('2024-01-01')]
);

// ‰ΩøÁî®ÂéüÁîü Drizzle Êü•ËØ¢
const client = dataProvider.getClient();
const users = await client
  .select()
  .from(schema.users)
  .where(gt(schema.users.createdAt, new Date('2024-01-01')));
```

## ÈÖçÁΩÆÈÄâÈ°π

### ËøûÊé•Ê±†

```typescript
const dataProvider = await createPostgreSQLProvider(connectionString, schema, {
  pool: {
    min: 2,
    max: 10,
    acquireTimeoutMillis: 30000,
    createTimeoutMillis: 30000,
    idleTimeoutMillis: 600000,
  },
});
```

### Êó•ÂøóÂíåË∞ÉËØï

```typescript
const dataProvider = await createPostgreSQLProvider(connectionString, schema, {
  debug: true,
  logger: (query, params) => {
    console.log('Êü•ËØ¢:', query);
    console.log('ÂèÇÊï∞:', params);
  },
});
```

## ËøêË°åÊó∂ÊîØÊåÅ

| ËøêË°åÊó∂             | PostgreSQL  | MySQL     | SQLite            |
| ------------------ | ----------- | --------- | ----------------- |
| Bun                | ‚úÖ bun:sql  | ‚úÖ mysql2 | ‚úÖ bun:sqlite     |
| Node.js            | ‚úÖ postgres | ‚úÖ mysql2 | ‚úÖ better-sqlite3 |
| Cloudflare Workers | ‚ùå          | ‚ùå        | ‚úÖ D1             |

## ÈîôËØØÂ§ÑÁêÜ

```typescript
import {
  ConnectionError,
  QueryError,
  ValidationError,
  TransactionError,
} from '@refine-sqlx/sqlx';

try {
  const result = await dataProvider.getList({ resource: 'users' });
} catch (error) {
  if (error instanceof ConnectionError) {
    console.error('Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•:', error.message);
  } else if (error instanceof QueryError) {
    console.error('Êü•ËØ¢ÊâßË°åÂ§±Ë¥•:', error.message);
  } else if (error instanceof ValidationError) {
    console.error('Êï∞ÊçÆÈ™åËØÅÂ§±Ë¥•:', error.message);
  }
}
```

## ‰ªéÂÖ∂‰ªñÊèê‰æõÂô®ËøÅÁßª

### ‰ªé Simple REST

```typescript
// ‰πãÂâç
const dataProvider = simpleRestProvider('http://localhost:3000/api');

// ‰πãÂêé
const dataProvider = await createPostgreSQLProvider(connectionString, schema);
```

### ‰ªé Supabase

```typescript
// ‰πãÂâç
const dataProvider = supabaseDataProvider(supabaseClient);

// ‰πãÂêé - ‰ΩøÁî® PostgreSQL ËøûÊé•
const dataProvider = await createPostgreSQLProvider(
  process.env.DATABASE_URL,
  schema
);
```

## API ÂèÇËÄÉ

### Ê†∏ÂøÉÂáΩÊï∞

- `createPostgreSQLProvider(connection, schema, options?)` - ÂàõÂª∫ PostgreSQL Êï∞ÊçÆÊèê‰æõÂô®
- `createMySQLProvider(connection, schema, options?)` - ÂàõÂª∫ MySQL Êï∞ÊçÆÊèê‰æõÂô®
- `createSQLiteProvider(connection, schema, options?)` - ÂàõÂª∫ SQLite Êï∞ÊçÆÊèê‰æõÂô®
- `createProvider(config)` - ÈÄöÁî®Êèê‰æõÂô®Â∑•ÂéÇ

### ÈìæÂºèÊü•ËØ¢ÊñπÊ≥ï

- `.where(field, operator, value)` - Ê∑ªÂä† WHERE Êù°‰ª∂
- `.orderBy(field, direction)` - Ê∑ªÂä† ORDER BY Â≠êÂè•
- `.limit(count)` - ËÆæÁΩÆ LIMIT
- `.offset(count)` - ËÆæÁΩÆ OFFSET
- `.with(relations)` - ÂåÖÂê´ÂÖ≥Á≥ª
- `.get()` - ÊâßË°åÂπ∂Ëé∑ÂèñÁªìÊûú
- `.first()` - Ëé∑ÂèñÁ¨¨‰∏Ä‰∏™ÁªìÊûú
- `.count()` - Ëé∑ÂèñËÆ°Êï∞
- `.paginate(page, perPage)` - ÂàÜÈ°µÁªìÊûú

### Â∑•ÂÖ∑ÂáΩÊï∞

- `testConnection(connectionString)` - ÊµãËØïÊï∞ÊçÆÂ∫ìËøûÊé•
- `validateSchema(schema)` - È™åËØÅ Drizzle Ê®°Âºè
- `getRuntimeInfo()` - Ëé∑ÂèñËøêË°åÊó∂ÂíåÈ©±Âä®‰ø°ÊÅØ

## Documentation

For comprehensive documentation, see:

- [Complete API Reference](../../docs/refine-orm/API.md)
- [Native Query Builders](../../docs/refine-orm/NATIVE_QUERY_BUILDERS.md)
- [Factory Functions](../../docs/refine-orm/FACTORY_FUNCTIONS.md)
- [User-Friendly API Guide](../../docs/refine-orm/USER_FRIENDLY_API.md)
- [PostgreSQL Adapter Guide](../../docs/refine-orm/postgresql-adapter.md)
- [MySQL Adapter Guide](../../docs/refine-orm/mysql-adapter.md)
- [All Documentation](../../docs/README.md)

## Ë¥°ÁåÆ

Êàë‰ª¨Ê¨¢ËøéË¥°ÁåÆÔºÅËØ∑Êü•ÁúãÊàë‰ª¨ÁöÑ [Ë¥°ÁåÆÊåáÂçó](../../CONTRIBUTING.md) ‰∫ÜËß£ËØ¶ÊÉÖ„ÄÇ

## ËÆ∏ÂèØËØÅ

MIT ¬© [RefineSQLX Team](https://github.com/zuohuadong/@refine-sqlx/sql)
